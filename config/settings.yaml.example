# Pixel components
components: {
  core: '127.0.0.1:9292',
}

#
# Link to the scripted dashboard for interface statistics
grafana_if_dash: 'http://graph.pixel.sd.dreamhost.com/#/dashboard/script/ne_interface.js'

#
# This is how device names are parsed.  See dev_rxp_matchkeys for more information.
dev_rxps: { 
  standard: !ruby/regexp '/^([a-zA-Z0-9]+)-([a-zA-Z]+)([0-9]+)([a-zA-Z0-9]+)-([a-zA-Z]+)(?:-([a-zA-Z]+))?$/',
  iad1: !ruby/regexp '/^([a-zA-Z0-9]+)-(\w)-([0-9])$/',
  special: !ruby/regexp '/^([a-zA-Z0-9]+)-([a-zA-Z0-9]+)-([0-9])$/',
}

# 
# dev_rxp_matchkeys associate each dev_rxp with the appropriate device attributes.
# Order in the sub-arrays are important, as the first value will define the first match
# from the regexp, etc.
# 
# Also, make sure there are an equal # of dev_rxp matches as array values in each 
# key set below.  It is OK to leave out values that you don't use in your device names, 
# but do not use any values other than the following:
#   - name (required)
#   - location
#   - row
#   - rack
#   - ru
#   - type
#   - subtype
#
dev_rxp_matchkeys: {
  standard: [
    'device', # device represents the entire match, which is always returned first
    'location',
    'row',
    'rack',
    'ru',
    'type',
    'subtype',
  ],
  iad1: [
    'device', # Name represents the entire match, which is always returned first
    'location',
    'row',
    'number',
  ],
  special: [
    'device', # Name represents the entire match, which is always returned first
    'location',
    'type',
    'number',
  ],
}

# This is used for converting location abbreviations to formal names.
locations: {
  gar: 'Garland',
  irv: 'Irvine',
  iad1: 'IAD1',
  aon: 'AON Office',
  brea: 'Brea Office',
  sf: 'SF Office',
}

# Interfaces are considered 'stale' this many seconds after the last poll.
stale_timeout: 600

# For converting link type abbreviations to formal names.
# If you change these, make sure you update interesting_alias
#   in the poller section as well.
# TODO: This needs to be reversed!
link_types: { 
  bb: 'Backbone', 
  acc: 'Access', 
  sub: 'Child', 
  trn: 'Transit',
}

# PostgreSQL database connection
pg_conn: {
  host: '127.0.0.1',
  db: 'pixel',
  user: 'postgres',
  pass: 'password',
}

# Poller configuration
poller: {
  concurrency: 15,
  influx_ip: '127.0.0.1',
  influx_user: 'user',
  influx_pass: 'pass',
  influx_db: 'snmp_data',
  snmpv2_community: 'public',
  # interesting_alias is the regex that determines whether or not
  # we process & store data, based on the interface description.
  interesting_alias: !ruby/regexp '/^trn__|^bb__|^acc__|^sub(\[|__)/',
}

# Where we're gonna get our devices
device_source: {
  type: 'file',
  file_path: 'config/hosts.yaml', # Must be a file with a list of yaml hashes { device => ip }
}

# API settings (for making calls between components)
api: {
  retry_count: 5,
  retry_delay: 5,
}
